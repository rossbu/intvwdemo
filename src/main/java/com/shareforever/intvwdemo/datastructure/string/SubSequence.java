package com.shareforever.intvwdemo.datastructure.string;


import java.util.ArrayList;
import java.util.Arrays;

/*
binary tree: https://www.geeksforgeeks.org/generating-all-possible-subsequences-using-recursion/
            https://www.youtube.com/watch?v=HEzpaUOAcds

            nary tree
            https://www.youtube.com/watch?v=0TVDNGLGXYg&t=23s
    In order :
    A String is a subsequence of a given String,
    that is generated by deleting some character of a given string without changing its order.

    Examples:

        Input : abc
        Output : a, b, c, ab, bc, ac, abc

        Input : aaa
        Output : a, aa, aaa

 */
public class SubSequence {

    public static void main(String[] args) {

        // include and exclude logic.
        char[] chars = {'a', 'b', 'c'};

//        printAllSS(chars, chars.length, 0, ssChars, 0);

        // binary tree search.
        String[] strings = {"a", "b", "c"};
//        binaryTree(strings, 0, new ArrayList());

        // nary tree
        naryTree(strings);

    }

    /*
        N-ary tree
     */
    private static void naryTree(String[] inputs) {
        String[] p = new String[inputs.length];
        for (int i = 0; i < inputs.length; i++) {
            naryTreeHelper(inputs, i, p, 0);
        }
    }

    private static void naryTreeHelper(String[] arrs, int idx, String[] p, int pi) {
        if (idx >= arrs.length) {
            System.out.println(Arrays.toString(p));
            return;
        }

        p[pi] = arrs[idx];
        System.out.println(Arrays.toString(p));
        // next one
        for (int i = idx + 1; i < arrs.length; i++) {
            naryTreeHelper(arrs, i, p, pi + 1);
        }
    }

    /*
        Binary tree
     */
    private static void binaryTree(String[] inputs, int ci, ArrayList<String> list) {
        if (ci == inputs.length) {
            list.forEach(e -> {
                System.out.print(e.equals("") ? "$" : e);
            });
            System.out.println();
            return;
        }

        // take it
        list.add(inputs[ci]);
        binaryTree(inputs, ci + 1, list);

        // don't take it
        list.remove(inputs[ci]);
        binaryTree(inputs, ci + 1, list);

    }


    // bad implemenation
    private static void printAllSS(char[] origin, int n, int ci, char[] ss, int cssi) {
        if (ci >= n) {
            System.out.print(Arrays.toString(ss));
            return;
        }

        // exclude
        printAllSS(origin, n, ci + 1, ss, cssi);

        // include
        ss[cssi] = origin[ci];
        printAllSS(origin, n, ci + 1, ss, cssi + 1);

    }
}
